def sudokuSolver (userInput):
	temp = [[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2],
			[0, 2, 2, 2, 2, 2, 2, 2, 2, 2]]
	board = []
	givens = 0
	for i in range(9):
		board.append(temp)
	for i in range(9):
		for j in range(9):
			if (userInput[i][j] >= 1):
				givens += 1
				clearSquareConflicts(board, i, j, userInput[i][j])
				clearBoardConflicts(board, i, j, userInput[i][j])
	if givens < 10:
		return userInput
	board = branchNbound(board)
	if board:
		for i in range(9):
			for j in range(9):
				userInput[i][j] = board[i][j][0]
	return userInput

def branchNbound (board):
	q = collections.deque() #use a deque as a queue
	q.append(board)
	while q and not solution(q[0]):
		#traverse rows and cols
		for i in range(9):
			for j in range(9):
				
				#guess each unsolved square, eliminate conflicts that arise
				if not board[i][j][0] == 0:
					#if this square is solved, don't guess it
					continue
				#if a guess is possible, try it
				for n in range(1,10) and q and q[0][i][j][n] == 2:
					temp = q[0]

					temp = clearSquareConflicts(temp, i, j, n)
					
					temp = clearBoardConflicts(temp, i, j, n)

					if valid(temp):
						q.append(temp)
					n += 1
				q.popLeft();
	if not q:
		return q[0]
	else:
		#error occured!
		return


def valid (board):
	for i in range(9):
		for j in range(9):
			if board[i][j][0] == 0:
				anyPossible = false;
				for n in range(1, 10):
					if board[i][j][n] != 0:
						anyPossible = True
				if (not anyPossible):
					return false
	return True

def clearSquareConflicts (board, row, col, basis):
	board[row][col][0] = basis
	board[row][col][basis] = 1
	for n in range(1, 10):
		if not n == basis:
			board[row][col][n] = 0
	return board

def clearBoardConflicts (board, row, col, basis):
	board = eliminateSubBoard(board, row, col, basis)
	board = eliminateRow (board, row, col, basis)
	return eliminateCol (board, row, col, basis)


def eliminateSubBoard (board, row, col, basis):
	subBoardRow = row//3
	subBoardCol = col//3

	for i in range(9):
		for j in range(9):
			if ((board [i][j][0] == 0) and (i//3 == subBoardRow)\
			and (j//3 == subBoardCol) and (i != row) and (j != col)):
				board[i][j][basis] = 0
	return board


def eliminateRow (board, row, col, basis):
	for j in range(9):
		if ((board [row][j][0] == 0) and (j != col)):
			board[row][j][basis] = 0;
	return board


def eliminateCol (board, row, col, basis):
	for i in range(9):
		if ((board [i][col][0] == 0) and (i != row)):
			board[i][col][basis] = 0;
	return board


def solution (board):
	for i in range(9):
		for j in range(9):
			if board[i][j][0] == 0:
				return False
	return True
